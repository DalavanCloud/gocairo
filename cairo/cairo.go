// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by gen.go, do not edit.

package cairo

import "unsafe"

/*
#cgo pkg-config: cairo
#include <cairo.h>
#include <stdlib.h>
*/
import "C"

// Error implements the error interface.
func (s Status) Error() string {
	return C.GoString(C.cairo_status_to_string(C.cairo_status_t(s)))
}

type ImageSurface struct {
	*Surface
}
type RecordingSurface struct {
	*Surface
}
type ToyFontFace struct {
	*FontFace
}
type MeshPattern struct {
	*Pattern
}

// See cairo_version().
func Version() int {
	ret := int(C.cairo_version())
	return ret
}

// See cairo_version_string().
func VersionString() string {
	ret := C.GoString(C.cairo_version_string())
	return ret
}

// See cairo_t.
type Context struct {
	Ptr *C.cairo_t
}

func wrapContext(p *C.cairo_t) *Context {
	// TODO: finalizer
	return &Context{p}
}

// See cairo_surface_t.
type Surface struct {
	Ptr *C.cairo_surface_t
}

func wrapSurface(p *C.cairo_surface_t) *Surface {
	// TODO: finalizer
	return &Surface{p}
}

// See cairo_device_t.
type Device struct {
	Ptr *C.cairo_device_t
}

func wrapDevice(p *C.cairo_device_t) *Device {
	// TODO: finalizer
	return &Device{p}
}

// See cairo_matrix_t.
type Matrix struct {
	Xx float64
	Yx float64
	Xy float64
	Yy float64
	X0 float64
	Y0 float64
}

// See cairo_pattern_t.
type Pattern struct {
	Ptr *C.cairo_pattern_t
}

func wrapPattern(p *C.cairo_pattern_t) *Pattern {
	// TODO: finalizer
	return &Pattern{p}
}

// See cairo_status_t.
type Status int

const (
	StatusSuccess                 Status = C.CAIRO_STATUS_SUCCESS
	StatusNoMemory                Status = C.CAIRO_STATUS_NO_MEMORY
	StatusInvalidRestore          Status = C.CAIRO_STATUS_INVALID_RESTORE
	StatusInvalidPopGroup         Status = C.CAIRO_STATUS_INVALID_POP_GROUP
	StatusNoCurrentPoint          Status = C.CAIRO_STATUS_NO_CURRENT_POINT
	StatusInvalidMatrix           Status = C.CAIRO_STATUS_INVALID_MATRIX
	StatusInvalidStatus           Status = C.CAIRO_STATUS_INVALID_STATUS
	StatusNullPointer             Status = C.CAIRO_STATUS_NULL_POINTER
	StatusInvalidString           Status = C.CAIRO_STATUS_INVALID_STRING
	StatusInvalidPathData         Status = C.CAIRO_STATUS_INVALID_PATH_DATA
	StatusReadError               Status = C.CAIRO_STATUS_READ_ERROR
	StatusWriteError              Status = C.CAIRO_STATUS_WRITE_ERROR
	StatusSurfaceFinished         Status = C.CAIRO_STATUS_SURFACE_FINISHED
	StatusSurfaceTypeMismatch     Status = C.CAIRO_STATUS_SURFACE_TYPE_MISMATCH
	StatusPatternTypeMismatch     Status = C.CAIRO_STATUS_PATTERN_TYPE_MISMATCH
	StatusInvalidContent          Status = C.CAIRO_STATUS_INVALID_CONTENT
	StatusInvalidFormat           Status = C.CAIRO_STATUS_INVALID_FORMAT
	StatusInvalidVisual           Status = C.CAIRO_STATUS_INVALID_VISUAL
	StatusFileNotFound            Status = C.CAIRO_STATUS_FILE_NOT_FOUND
	StatusInvalidDash             Status = C.CAIRO_STATUS_INVALID_DASH
	StatusInvalidDscComment       Status = C.CAIRO_STATUS_INVALID_DSC_COMMENT
	StatusInvalidIndex            Status = C.CAIRO_STATUS_INVALID_INDEX
	StatusClipNotRepresentable    Status = C.CAIRO_STATUS_CLIP_NOT_REPRESENTABLE
	StatusTempFileError           Status = C.CAIRO_STATUS_TEMP_FILE_ERROR
	StatusInvalidStride           Status = C.CAIRO_STATUS_INVALID_STRIDE
	StatusFontTypeMismatch        Status = C.CAIRO_STATUS_FONT_TYPE_MISMATCH
	StatusUserFontImmutable       Status = C.CAIRO_STATUS_USER_FONT_IMMUTABLE
	StatusUserFontError           Status = C.CAIRO_STATUS_USER_FONT_ERROR
	StatusNegativeCount           Status = C.CAIRO_STATUS_NEGATIVE_COUNT
	StatusInvalidClusters         Status = C.CAIRO_STATUS_INVALID_CLUSTERS
	StatusInvalidSlant            Status = C.CAIRO_STATUS_INVALID_SLANT
	StatusInvalidWeight           Status = C.CAIRO_STATUS_INVALID_WEIGHT
	StatusInvalidSize             Status = C.CAIRO_STATUS_INVALID_SIZE
	StatusUserFontNotImplemented  Status = C.CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED
	StatusDeviceTypeMismatch      Status = C.CAIRO_STATUS_DEVICE_TYPE_MISMATCH
	StatusDeviceError             Status = C.CAIRO_STATUS_DEVICE_ERROR
	StatusInvalidMeshConstruction Status = C.CAIRO_STATUS_INVALID_MESH_CONSTRUCTION
	StatusDeviceFinished          Status = C.CAIRO_STATUS_DEVICE_FINISHED
	StatusJbig2GlobalMissing      Status = C.CAIRO_STATUS_JBIG2_GLOBAL_MISSING
	StatusLastStatus              Status = C.CAIRO_STATUS_LAST_STATUS
)

// See cairo_content_t.
type Content int

const (
	ContentColor      Content = C.CAIRO_CONTENT_COLOR
	ContentAlpha      Content = C.CAIRO_CONTENT_ALPHA
	ContentColorAlpha Content = C.CAIRO_CONTENT_COLOR_ALPHA
)

// See cairo_format_t.
type Format int

const (
	FormatInvalid  Format = C.CAIRO_FORMAT_INVALID
	FormatArgb32   Format = C.CAIRO_FORMAT_ARGB32
	FormatRgb24    Format = C.CAIRO_FORMAT_RGB24
	FormatA8       Format = C.CAIRO_FORMAT_A8
	FormatA1       Format = C.CAIRO_FORMAT_A1
	FormatRgb16565 Format = C.CAIRO_FORMAT_RGB16_565
	FormatRgb30    Format = C.CAIRO_FORMAT_RGB30
)

// See cairo_create().
func Create(target *Surface) *Context {
	ret := wrapContext(C.cairo_create(target.Ptr))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_save().
func (cr *Context) Save() {
	C.cairo_save(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_restore().
func (cr *Context) Restore() {
	C.cairo_restore(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_push_group().
func (cr *Context) PushGroup() {
	C.cairo_push_group(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_push_group_with_content().
func (cr *Context) PushGroupWithContent(content Content) {
	C.cairo_push_group_with_content(cr.Ptr, C.cairo_content_t(content))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_pop_group().
func (cr *Context) PopGroup() *Pattern {
	ret := wrapPattern(C.cairo_pop_group(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pop_group_to_source().
func (cr *Context) PopGroupToSource() {
	C.cairo_pop_group_to_source(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_operator_t.
type Operator int

const (
	OperatorClear         Operator = C.CAIRO_OPERATOR_CLEAR
	OperatorSource        Operator = C.CAIRO_OPERATOR_SOURCE
	OperatorOver          Operator = C.CAIRO_OPERATOR_OVER
	OperatorIn            Operator = C.CAIRO_OPERATOR_IN
	OperatorOut           Operator = C.CAIRO_OPERATOR_OUT
	OperatorAtop          Operator = C.CAIRO_OPERATOR_ATOP
	OperatorDest          Operator = C.CAIRO_OPERATOR_DEST
	OperatorDestOver      Operator = C.CAIRO_OPERATOR_DEST_OVER
	OperatorDestIn        Operator = C.CAIRO_OPERATOR_DEST_IN
	OperatorDestOut       Operator = C.CAIRO_OPERATOR_DEST_OUT
	OperatorDestAtop      Operator = C.CAIRO_OPERATOR_DEST_ATOP
	OperatorXor           Operator = C.CAIRO_OPERATOR_XOR
	OperatorAdd           Operator = C.CAIRO_OPERATOR_ADD
	OperatorSaturate      Operator = C.CAIRO_OPERATOR_SATURATE
	OperatorMultiply      Operator = C.CAIRO_OPERATOR_MULTIPLY
	OperatorScreen        Operator = C.CAIRO_OPERATOR_SCREEN
	OperatorOverlay       Operator = C.CAIRO_OPERATOR_OVERLAY
	OperatorDarken        Operator = C.CAIRO_OPERATOR_DARKEN
	OperatorLighten       Operator = C.CAIRO_OPERATOR_LIGHTEN
	OperatorColorDodge    Operator = C.CAIRO_OPERATOR_COLOR_DODGE
	OperatorColorBurn     Operator = C.CAIRO_OPERATOR_COLOR_BURN
	OperatorHardLight     Operator = C.CAIRO_OPERATOR_HARD_LIGHT
	OperatorSoftLight     Operator = C.CAIRO_OPERATOR_SOFT_LIGHT
	OperatorDifference    Operator = C.CAIRO_OPERATOR_DIFFERENCE
	OperatorExclusion     Operator = C.CAIRO_OPERATOR_EXCLUSION
	OperatorHslHue        Operator = C.CAIRO_OPERATOR_HSL_HUE
	OperatorHslSaturation Operator = C.CAIRO_OPERATOR_HSL_SATURATION
	OperatorHslColor      Operator = C.CAIRO_OPERATOR_HSL_COLOR
	OperatorHslLuminosity Operator = C.CAIRO_OPERATOR_HSL_LUMINOSITY
)

// See cairo_set_operator().
func (cr *Context) SetOperator(op Operator) {
	C.cairo_set_operator(cr.Ptr, C.cairo_operator_t(op))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_source().
func (cr *Context) SetSource(source *Pattern) {
	C.cairo_set_source(cr.Ptr, source.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_source_rgb().
func (cr *Context) SetSourceRgb(red float64, green float64, blue float64) {
	C.cairo_set_source_rgb(cr.Ptr, C.double(red), C.double(green), C.double(blue))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_source_rgba().
func (cr *Context) SetSourceRgba(red float64, green float64, blue float64, alpha float64) {
	C.cairo_set_source_rgba(cr.Ptr, C.double(red), C.double(green), C.double(blue), C.double(alpha))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_source_surface().
func (cr *Context) SetSourceSurface(surface *Surface, x float64, y float64) {
	C.cairo_set_source_surface(cr.Ptr, surface.Ptr, C.double(x), C.double(y))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_tolerance().
func (cr *Context) SetTolerance(tolerance float64) {
	C.cairo_set_tolerance(cr.Ptr, C.double(tolerance))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_antialias_t.
type Antialias int

const (
	AntialiasDefault  Antialias = C.CAIRO_ANTIALIAS_DEFAULT
	AntialiasNone     Antialias = C.CAIRO_ANTIALIAS_NONE
	AntialiasGray     Antialias = C.CAIRO_ANTIALIAS_GRAY
	AntialiasSubpixel Antialias = C.CAIRO_ANTIALIAS_SUBPIXEL
	AntialiasFast     Antialias = C.CAIRO_ANTIALIAS_FAST
	AntialiasGood     Antialias = C.CAIRO_ANTIALIAS_GOOD
	AntialiasBest     Antialias = C.CAIRO_ANTIALIAS_BEST
)

// See cairo_set_antialias().
func (cr *Context) SetAntialias(antialias Antialias) {
	C.cairo_set_antialias(cr.Ptr, C.cairo_antialias_t(antialias))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_fill_rule_t.
type FillRule int

const (
	FillRuleWinding FillRule = C.CAIRO_FILL_RULE_WINDING
	FillRuleEvenOdd FillRule = C.CAIRO_FILL_RULE_EVEN_ODD
)

// See cairo_set_fill_rule().
func (cr *Context) SetFillRule(fillRule FillRule) {
	C.cairo_set_fill_rule(cr.Ptr, C.cairo_fill_rule_t(fillRule))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_line_width().
func (cr *Context) SetLineWidth(width float64) {
	C.cairo_set_line_width(cr.Ptr, C.double(width))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_line_cap_t.
type LineCap int

const (
	LineCapButt   LineCap = C.CAIRO_LINE_CAP_BUTT
	LineCapRound  LineCap = C.CAIRO_LINE_CAP_ROUND
	LineCapSquare LineCap = C.CAIRO_LINE_CAP_SQUARE
)

// See cairo_set_line_cap().
func (cr *Context) SetLineCap(lineCap LineCap) {
	C.cairo_set_line_cap(cr.Ptr, C.cairo_line_cap_t(lineCap))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_line_join_t.
type LineJoin int

const (
	LineJoinMiter LineJoin = C.CAIRO_LINE_JOIN_MITER
	LineJoinRound LineJoin = C.CAIRO_LINE_JOIN_ROUND
	LineJoinBevel LineJoin = C.CAIRO_LINE_JOIN_BEVEL
)

// See cairo_set_line_join().
func (cr *Context) SetLineJoin(lineJoin LineJoin) {
	C.cairo_set_line_join(cr.Ptr, C.cairo_line_join_t(lineJoin))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_dash().
func (cr *Context) SetDash(dashes []float64, offset float64) {
	C.cairo_set_dash(cr.Ptr, (*C.double)(sliceBytes(unsafe.Pointer(&dashes))), C.int(len(dashes)), C.double(offset))
}

// See cairo_set_miter_limit().
func (cr *Context) SetMiterLimit(limit float64) {
	C.cairo_set_miter_limit(cr.Ptr, C.double(limit))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_translate().
func (cr *Context) Translate(tx float64, ty float64) {
	C.cairo_translate(cr.Ptr, C.double(tx), C.double(ty))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_scale().
func (cr *Context) Scale(sx float64, sy float64) {
	C.cairo_scale(cr.Ptr, C.double(sx), C.double(sy))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_rotate().
func (cr *Context) Rotate(angle float64) {
	C.cairo_rotate(cr.Ptr, C.double(angle))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_transform().
func (cr *Context) Transform(matrix *Matrix) {
	C.cairo_transform(cr.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_matrix().
func (cr *Context) SetMatrix(matrix *Matrix) {
	C.cairo_set_matrix(cr.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_identity_matrix().
func (cr *Context) IdentityMatrix() {
	C.cairo_identity_matrix(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_user_to_device().
func (cr *Context) UserToDevice(x *float64, y *float64) {
	C.cairo_user_to_device(cr.Ptr, (*C.double)(unsafe.Pointer(x)), (*C.double)(unsafe.Pointer(y)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_user_to_device_distance().
func (cr *Context) UserToDeviceDistance(dx *float64, dy *float64) {
	C.cairo_user_to_device_distance(cr.Ptr, (*C.double)(unsafe.Pointer(dx)), (*C.double)(unsafe.Pointer(dy)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_device_to_user().
func (cr *Context) DeviceToUser(x *float64, y *float64) {
	C.cairo_device_to_user(cr.Ptr, (*C.double)(unsafe.Pointer(x)), (*C.double)(unsafe.Pointer(y)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_device_to_user_distance().
func (cr *Context) DeviceToUserDistance(dx *float64, dy *float64) {
	C.cairo_device_to_user_distance(cr.Ptr, (*C.double)(unsafe.Pointer(dx)), (*C.double)(unsafe.Pointer(dy)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_new_path().
func (cr *Context) NewPath() {
	C.cairo_new_path(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_move_to().
func (cr *Context) MoveTo(x float64, y float64) {
	C.cairo_move_to(cr.Ptr, C.double(x), C.double(y))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_new_sub_path().
func (cr *Context) NewSubPath() {
	C.cairo_new_sub_path(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_line_to().
func (cr *Context) LineTo(x float64, y float64) {
	C.cairo_line_to(cr.Ptr, C.double(x), C.double(y))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_curve_to().
func (cr *Context) CurveTo(x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64) {
	C.cairo_curve_to(cr.Ptr, C.double(x1), C.double(y1), C.double(x2), C.double(y2), C.double(x3), C.double(y3))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_arc().
func (cr *Context) Arc(xc float64, yc float64, radius float64, angle1 float64, angle2 float64) {
	C.cairo_arc(cr.Ptr, C.double(xc), C.double(yc), C.double(radius), C.double(angle1), C.double(angle2))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_arc_negative().
func (cr *Context) ArcNegative(xc float64, yc float64, radius float64, angle1 float64, angle2 float64) {
	C.cairo_arc_negative(cr.Ptr, C.double(xc), C.double(yc), C.double(radius), C.double(angle1), C.double(angle2))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_rel_move_to().
func (cr *Context) RelMoveTo(dx float64, dy float64) {
	C.cairo_rel_move_to(cr.Ptr, C.double(dx), C.double(dy))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_rel_line_to().
func (cr *Context) RelLineTo(dx float64, dy float64) {
	C.cairo_rel_line_to(cr.Ptr, C.double(dx), C.double(dy))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_rel_curve_to().
func (cr *Context) RelCurveTo(dx1 float64, dy1 float64, dx2 float64, dy2 float64, dx3 float64, dy3 float64) {
	C.cairo_rel_curve_to(cr.Ptr, C.double(dx1), C.double(dy1), C.double(dx2), C.double(dy2), C.double(dx3), C.double(dy3))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_rectangle().
func (cr *Context) Rectangle(x float64, y float64, width float64, height float64) {
	C.cairo_rectangle(cr.Ptr, C.double(x), C.double(y), C.double(width), C.double(height))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_close_path().
func (cr *Context) ClosePath() {
	C.cairo_close_path(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_path_extents().
func (cr *Context) PathExtents() (float64, float64, float64, float64) {
	var x1 C.double
	var y1 C.double
	var x2 C.double
	var y2 C.double

	C.cairo_path_extents(cr.Ptr, &x1, &y1, &x2, &y2)
	if err := cr.status(); err != nil {
		panic(err)
	}
	return float64(x1), float64(y1), float64(x2), float64(y2)
}

// See cairo_paint().
func (cr *Context) Paint() {
	C.cairo_paint(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_paint_with_alpha().
func (cr *Context) PaintWithAlpha(alpha float64) {
	C.cairo_paint_with_alpha(cr.Ptr, C.double(alpha))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_mask().
func (cr *Context) Mask(pattern *Pattern) {
	C.cairo_mask(cr.Ptr, pattern.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_mask_surface().
func (cr *Context) MaskSurface(surface *Surface, surfaceX float64, surfaceY float64) {
	C.cairo_mask_surface(cr.Ptr, surface.Ptr, C.double(surfaceX), C.double(surfaceY))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_stroke().
func (cr *Context) Stroke() {
	C.cairo_stroke(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_stroke_preserve().
func (cr *Context) StrokePreserve() {
	C.cairo_stroke_preserve(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_fill().
func (cr *Context) Fill() {
	C.cairo_fill(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_fill_preserve().
func (cr *Context) FillPreserve() {
	C.cairo_fill_preserve(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_copy_page().
func (cr *Context) CopyPage() {
	C.cairo_copy_page(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_show_page().
func (cr *Context) ShowPage() {
	C.cairo_show_page(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_in_stroke().
func (cr *Context) InStroke(x float64, y float64) bool {
	ret := C.cairo_in_stroke(cr.Ptr, C.double(x), C.double(y)) != 0
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_in_fill().
func (cr *Context) InFill(x float64, y float64) bool {
	ret := C.cairo_in_fill(cr.Ptr, C.double(x), C.double(y)) != 0
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_in_clip().
func (cr *Context) InClip(x float64, y float64) bool {
	ret := C.cairo_in_clip(cr.Ptr, C.double(x), C.double(y)) != 0
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_stroke_extents().
func (cr *Context) StrokeExtents() (float64, float64, float64, float64) {
	var x1 C.double
	var y1 C.double
	var x2 C.double
	var y2 C.double

	C.cairo_stroke_extents(cr.Ptr, &x1, &y1, &x2, &y2)
	if err := cr.status(); err != nil {
		panic(err)
	}
	return float64(x1), float64(y1), float64(x2), float64(y2)
}

// See cairo_fill_extents().
func (cr *Context) FillExtents() (float64, float64, float64, float64) {
	var x1 C.double
	var y1 C.double
	var x2 C.double
	var y2 C.double

	C.cairo_fill_extents(cr.Ptr, &x1, &y1, &x2, &y2)
	if err := cr.status(); err != nil {
		panic(err)
	}
	return float64(x1), float64(y1), float64(x2), float64(y2)
}

// See cairo_reset_clip().
func (cr *Context) ResetClip() {
	C.cairo_reset_clip(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_clip().
func (cr *Context) Clip() {
	C.cairo_clip(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_clip_preserve().
func (cr *Context) ClipPreserve() {
	C.cairo_clip_preserve(cr.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_clip_extents().
func (cr *Context) ClipExtents() (float64, float64, float64, float64) {
	var x1 C.double
	var y1 C.double
	var x2 C.double
	var y2 C.double

	C.cairo_clip_extents(cr.Ptr, &x1, &y1, &x2, &y2)
	if err := cr.status(); err != nil {
		panic(err)
	}
	return float64(x1), float64(y1), float64(x2), float64(y2)
}

// See cairo_rectangle_t.
type Rectangle struct {
	X      float64
	Y      float64
	Width  float64
	Height float64
}

// See cairo_scaled_font_t.
type ScaledFont struct {
	Ptr *C.cairo_scaled_font_t
}

func wrapScaledFont(p *C.cairo_scaled_font_t) *ScaledFont {
	// TODO: finalizer
	return &ScaledFont{p}
}

// See cairo_font_face_t.
type FontFace struct {
	Ptr *C.cairo_font_face_t
}

func wrapFontFace(p *C.cairo_font_face_t) *FontFace {
	// TODO: finalizer
	return &FontFace{p}
}

// See cairo_text_cluster_flags_t.
type TextClusterFlags int

const (
	TextClusterFlagBackward TextClusterFlags = C.CAIRO_TEXT_CLUSTER_FLAG_BACKWARD
)

// See cairo_text_extents_t.
type TextExtents struct {
	XBearing float64
	YBearing float64
	Width    float64
	Height   float64
	XAdvance float64
	YAdvance float64
}

// See cairo_font_extents_t.
type FontExtents struct {
	Ascent      float64
	Descent     float64
	Height      float64
	MaxXAdvance float64
	MaxYAdvance float64
}

// See cairo_font_slant_t.
type FontSlant int

const (
	FontSlantNormal  FontSlant = C.CAIRO_FONT_SLANT_NORMAL
	FontSlantItalic  FontSlant = C.CAIRO_FONT_SLANT_ITALIC
	FontSlantOblique FontSlant = C.CAIRO_FONT_SLANT_OBLIQUE
)

// See cairo_font_weight_t.
type FontWeight int

const (
	FontWeightNormal FontWeight = C.CAIRO_FONT_WEIGHT_NORMAL
	FontWeightBold   FontWeight = C.CAIRO_FONT_WEIGHT_BOLD
)

// See cairo_subpixel_order_t.
type SubpixelOrder int

const (
	SubpixelOrderDefault SubpixelOrder = C.CAIRO_SUBPIXEL_ORDER_DEFAULT
	SubpixelOrderRgb     SubpixelOrder = C.CAIRO_SUBPIXEL_ORDER_RGB
	SubpixelOrderBgr     SubpixelOrder = C.CAIRO_SUBPIXEL_ORDER_BGR
	SubpixelOrderVrgb    SubpixelOrder = C.CAIRO_SUBPIXEL_ORDER_VRGB
	SubpixelOrderVbgr    SubpixelOrder = C.CAIRO_SUBPIXEL_ORDER_VBGR
)

// See cairo_hint_style_t.
type HintStyle int

const (
	HintStyleDefault HintStyle = C.CAIRO_HINT_STYLE_DEFAULT
	HintStyleNone    HintStyle = C.CAIRO_HINT_STYLE_NONE
	HintStyleSlight  HintStyle = C.CAIRO_HINT_STYLE_SLIGHT
	HintStyleMedium  HintStyle = C.CAIRO_HINT_STYLE_MEDIUM
	HintStyleFull    HintStyle = C.CAIRO_HINT_STYLE_FULL
)

// See cairo_hint_metrics_t.
type HintMetrics int

const (
	HintMetricsDefault HintMetrics = C.CAIRO_HINT_METRICS_DEFAULT
	HintMetricsOff     HintMetrics = C.CAIRO_HINT_METRICS_OFF
	HintMetricsOn      HintMetrics = C.CAIRO_HINT_METRICS_ON
)

// See cairo_font_options_t.
type FontOptions struct {
	Ptr *C.cairo_font_options_t
}

func wrapFontOptions(p *C.cairo_font_options_t) *FontOptions {
	// TODO: finalizer
	return &FontOptions{p}
}

// See cairo_font_options_create().
func FontOptionsCreate() *FontOptions {
	ret := wrapFontOptions(C.cairo_font_options_create())
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_copy().
func (original *FontOptions) Copy() *FontOptions {
	ret := wrapFontOptions(C.cairo_font_options_copy(original.Ptr))
	if err := original.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_status().
func (options *FontOptions) status() error {
	ret := Status(C.cairo_font_options_status(options.Ptr)).toError()
	return ret
}

// See cairo_font_options_merge().
func (options *FontOptions) Merge(other *FontOptions) {
	C.cairo_font_options_merge(options.Ptr, other.Ptr)
	if err := options.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_options_equal().
func (options *FontOptions) Equal(other *FontOptions) bool {
	ret := C.cairo_font_options_equal(options.Ptr, other.Ptr) != 0
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_hash().
func (options *FontOptions) Hash() uint32 {
	ret := uint32(C.cairo_font_options_hash(options.Ptr))
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_set_antialias().
func (options *FontOptions) SetAntialias(antialias Antialias) {
	C.cairo_font_options_set_antialias(options.Ptr, C.cairo_antialias_t(antialias))
	if err := options.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_options_get_antialias().
func (options *FontOptions) GetAntialias() Antialias {
	ret := Antialias(C.cairo_font_options_get_antialias(options.Ptr))
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_set_subpixel_order().
func (options *FontOptions) SetSubpixelOrder(subpixelOrder SubpixelOrder) {
	C.cairo_font_options_set_subpixel_order(options.Ptr, C.cairo_subpixel_order_t(subpixelOrder))
	if err := options.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_options_get_subpixel_order().
func (options *FontOptions) GetSubpixelOrder() SubpixelOrder {
	ret := SubpixelOrder(C.cairo_font_options_get_subpixel_order(options.Ptr))
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_set_hint_style().
func (options *FontOptions) SetHintStyle(hintStyle HintStyle) {
	C.cairo_font_options_set_hint_style(options.Ptr, C.cairo_hint_style_t(hintStyle))
	if err := options.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_options_get_hint_style().
func (options *FontOptions) GetHintStyle() HintStyle {
	ret := HintStyle(C.cairo_font_options_get_hint_style(options.Ptr))
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_font_options_set_hint_metrics().
func (options *FontOptions) SetHintMetrics(hintMetrics HintMetrics) {
	C.cairo_font_options_set_hint_metrics(options.Ptr, C.cairo_hint_metrics_t(hintMetrics))
	if err := options.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_options_get_hint_metrics().
func (options *FontOptions) GetHintMetrics() HintMetrics {
	ret := HintMetrics(C.cairo_font_options_get_hint_metrics(options.Ptr))
	if err := options.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_select_font_face().
func (cr *Context) SelectFontFace(family string, slant FontSlant, weight FontWeight) {
	c_family := C.CString(family)
	defer C.free(unsafe.Pointer(c_family))
	C.cairo_select_font_face(cr.Ptr, c_family, C.cairo_font_slant_t(slant), C.cairo_font_weight_t(weight))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_font_size().
func (cr *Context) SetFontSize(size float64) {
	C.cairo_set_font_size(cr.Ptr, C.double(size))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_font_matrix().
func (cr *Context) SetFontMatrix(matrix *Matrix) {
	C.cairo_set_font_matrix(cr.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_font_matrix().
func (cr *Context) GetFontMatrix(matrix *Matrix) {
	C.cairo_get_font_matrix(cr.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_font_options().
func (cr *Context) SetFontOptions(options *FontOptions) {
	C.cairo_set_font_options(cr.Ptr, options.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_font_options().
func (cr *Context) GetFontOptions(options *FontOptions) {
	C.cairo_get_font_options(cr.Ptr, options.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_set_font_face().
func (cr *Context) SetFontFace(fontFace *FontFace) {
	C.cairo_set_font_face(cr.Ptr, fontFace.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_font_face().
func (cr *Context) GetFontFace() *FontFace {
	ret := wrapFontFace(C.cairo_get_font_face(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_set_scaled_font().
func (cr *Context) SetScaledFont(scaledFont *ScaledFont) {
	C.cairo_set_scaled_font(cr.Ptr, scaledFont.Ptr)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_scaled_font().
func (cr *Context) GetScaledFont() *ScaledFont {
	ret := wrapScaledFont(C.cairo_get_scaled_font(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_show_text().
func (cr *Context) ShowText(utf8 string) {
	c_utf8 := C.CString(utf8)
	defer C.free(unsafe.Pointer(c_utf8))
	C.cairo_show_text(cr.Ptr, c_utf8)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_text_path().
func (cr *Context) TextPath(utf8 string) {
	c_utf8 := C.CString(utf8)
	defer C.free(unsafe.Pointer(c_utf8))
	C.cairo_text_path(cr.Ptr, c_utf8)
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_text_extents().
func (cr *Context) TextExtents(utf8 string, extents *TextExtents) {
	c_utf8 := C.CString(utf8)
	defer C.free(unsafe.Pointer(c_utf8))
	C.cairo_text_extents(cr.Ptr, c_utf8, (*C.cairo_text_extents_t)(unsafe.Pointer(extents)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_extents().
func (cr *Context) FontExtents(extents *FontExtents) {
	C.cairo_font_extents(cr.Ptr, (*C.cairo_font_extents_t)(unsafe.Pointer(extents)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_font_face_status().
func (fontFace *FontFace) status() error {
	ret := Status(C.cairo_font_face_status(fontFace.Ptr)).toError()
	return ret
}

// See cairo_font_type_t.
type FontType int

const (
	FontTypeToy    FontType = C.CAIRO_FONT_TYPE_TOY
	FontTypeFt     FontType = C.CAIRO_FONT_TYPE_FT
	FontTypeWin32  FontType = C.CAIRO_FONT_TYPE_WIN32
	FontTypeQuartz FontType = C.CAIRO_FONT_TYPE_QUARTZ
	FontTypeUser   FontType = C.CAIRO_FONT_TYPE_USER
)

// See cairo_font_face_get_type().
func (fontFace *FontFace) GetType() FontType {
	ret := FontType(C.cairo_font_face_get_type(fontFace.Ptr))
	if err := fontFace.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_scaled_font_create().
func ScaledFontCreate(fontFace *FontFace, fontMatrix *Matrix, ctm *Matrix, options *FontOptions) *ScaledFont {
	ret := wrapScaledFont(C.cairo_scaled_font_create(fontFace.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(fontMatrix)), (*C.cairo_matrix_t)(unsafe.Pointer(ctm)), options.Ptr))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_scaled_font_status().
func (scaledFont *ScaledFont) status() error {
	ret := Status(C.cairo_scaled_font_status(scaledFont.Ptr)).toError()
	return ret
}

// See cairo_scaled_font_get_type().
func (scaledFont *ScaledFont) GetType() FontType {
	ret := FontType(C.cairo_scaled_font_get_type(scaledFont.Ptr))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_scaled_font_extents().
func (scaledFont *ScaledFont) Extents(extents *FontExtents) {
	C.cairo_scaled_font_extents(scaledFont.Ptr, (*C.cairo_font_extents_t)(unsafe.Pointer(extents)))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_scaled_font_text_extents().
func (scaledFont *ScaledFont) TextExtents(utf8 string, extents *TextExtents) {
	c_utf8 := C.CString(utf8)
	defer C.free(unsafe.Pointer(c_utf8))
	C.cairo_scaled_font_text_extents(scaledFont.Ptr, c_utf8, (*C.cairo_text_extents_t)(unsafe.Pointer(extents)))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_scaled_font_get_font_face().
func (scaledFont *ScaledFont) GetFontFace() *FontFace {
	ret := wrapFontFace(C.cairo_scaled_font_get_font_face(scaledFont.Ptr))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_scaled_font_get_font_matrix().
func (scaledFont *ScaledFont) GetFontMatrix(fontMatrix *Matrix) {
	C.cairo_scaled_font_get_font_matrix(scaledFont.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(fontMatrix)))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_scaled_font_get_ctm().
func (scaledFont *ScaledFont) GetCtm(ctm *Matrix) {
	C.cairo_scaled_font_get_ctm(scaledFont.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(ctm)))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_scaled_font_get_scale_matrix().
func (scaledFont *ScaledFont) GetScaleMatrix(scaleMatrix *Matrix) {
	C.cairo_scaled_font_get_scale_matrix(scaledFont.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(scaleMatrix)))
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_scaled_font_get_font_options().
func (scaledFont *ScaledFont) GetFontOptions(options *FontOptions) {
	C.cairo_scaled_font_get_font_options(scaledFont.Ptr, options.Ptr)
	if err := scaledFont.status(); err != nil {
		panic(err)
	}
}

// See cairo_toy_font_face_create().
func ToyFontFaceCreate(family string, slant FontSlant, weight FontWeight) *ToyFontFace {
	c_family := C.CString(family)
	defer C.free(unsafe.Pointer(c_family))
	ret := &ToyFontFace{wrapFontFace(C.cairo_toy_font_face_create(c_family, C.cairo_font_slant_t(slant), C.cairo_font_weight_t(weight)))}
	return ret
}

// See cairo_toy_font_face_get_family().
func (fontFace *ToyFontFace) GetFamily() string {
	ret := C.GoString(C.cairo_toy_font_face_get_family(fontFace.Ptr))
	if err := fontFace.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_toy_font_face_get_slant().
func (fontFace *ToyFontFace) GetSlant() FontSlant {
	ret := FontSlant(C.cairo_toy_font_face_get_slant(fontFace.Ptr))
	if err := fontFace.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_toy_font_face_get_weight().
func (fontFace *ToyFontFace) GetWeight() FontWeight {
	ret := FontWeight(C.cairo_toy_font_face_get_weight(fontFace.Ptr))
	if err := fontFace.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_user_font_face_create().
func UserFontFaceCreate() *FontFace {
	ret := wrapFontFace(C.cairo_user_font_face_create())
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_operator().
func (cr *Context) GetOperator() Operator {
	ret := Operator(C.cairo_get_operator(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_source().
func (cr *Context) GetSource() *Pattern {
	ret := wrapPattern(C.cairo_get_source(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_tolerance().
func (cr *Context) GetTolerance() float64 {
	ret := float64(C.cairo_get_tolerance(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_antialias().
func (cr *Context) GetAntialias() Antialias {
	ret := Antialias(C.cairo_get_antialias(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_has_current_point().
func (cr *Context) HasCurrentPoint() bool {
	ret := C.cairo_has_current_point(cr.Ptr) != 0
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_current_point().
func (cr *Context) GetCurrentPoint() (float64, float64) {
	var x C.double
	var y C.double

	C.cairo_get_current_point(cr.Ptr, &x, &y)
	if err := cr.status(); err != nil {
		panic(err)
	}
	return float64(x), float64(y)
}

// See cairo_get_fill_rule().
func (cr *Context) GetFillRule() FillRule {
	ret := FillRule(C.cairo_get_fill_rule(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_line_width().
func (cr *Context) GetLineWidth() float64 {
	ret := float64(C.cairo_get_line_width(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_line_cap().
func (cr *Context) GetLineCap() LineCap {
	ret := LineCap(C.cairo_get_line_cap(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_line_join().
func (cr *Context) GetLineJoin() LineJoin {
	ret := LineJoin(C.cairo_get_line_join(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_miter_limit().
func (cr *Context) GetMiterLimit() float64 {
	ret := float64(C.cairo_get_miter_limit(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_dash_count().
func (cr *Context) GetDashCount() int {
	ret := int(C.cairo_get_dash_count(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_dash().
func (cr *Context) GetDash(dashes *float64, offset *float64) {
	C.cairo_get_dash(cr.Ptr, (*C.double)(unsafe.Pointer(dashes)), (*C.double)(unsafe.Pointer(offset)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_matrix().
func (cr *Context) GetMatrix(matrix *Matrix) {
	C.cairo_get_matrix(cr.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := cr.status(); err != nil {
		panic(err)
	}
}

// See cairo_get_target().
func (cr *Context) GetTarget() *Surface {
	ret := wrapSurface(C.cairo_get_target(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_get_group_target().
func (cr *Context) GetGroupTarget() *Surface {
	ret := wrapSurface(C.cairo_get_group_target(cr.Ptr))
	if err := cr.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_path_data_type_t.
type PathDataType int

const (
	PathMoveTo    PathDataType = C.CAIRO_PATH_MOVE_TO
	PathLineTo    PathDataType = C.CAIRO_PATH_LINE_TO
	PathCurveTo   PathDataType = C.CAIRO_PATH_CURVE_TO
	PathClosePath PathDataType = C.CAIRO_PATH_CLOSE_PATH
)

// See cairo_status().
func (cr *Context) status() error {
	ret := Status(C.cairo_status(cr.Ptr)).toError()
	return ret
}

// See cairo_device_type_t.
type DeviceType int

const (
	DeviceTypeDrm     DeviceType = C.CAIRO_DEVICE_TYPE_DRM
	DeviceTypeGl      DeviceType = C.CAIRO_DEVICE_TYPE_GL
	DeviceTypeScript  DeviceType = C.CAIRO_DEVICE_TYPE_SCRIPT
	DeviceTypeXcb     DeviceType = C.CAIRO_DEVICE_TYPE_XCB
	DeviceTypeXlib    DeviceType = C.CAIRO_DEVICE_TYPE_XLIB
	DeviceTypeXml     DeviceType = C.CAIRO_DEVICE_TYPE_XML
	DeviceTypeCogl    DeviceType = C.CAIRO_DEVICE_TYPE_COGL
	DeviceTypeWin32   DeviceType = C.CAIRO_DEVICE_TYPE_WIN32
	DeviceTypeInvalid DeviceType = C.CAIRO_DEVICE_TYPE_INVALID
)

// See cairo_device_get_type().
func (device *Device) GetType() DeviceType {
	ret := DeviceType(C.cairo_device_get_type(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_status().
func (device *Device) status() error {
	ret := Status(C.cairo_device_status(device.Ptr)).toError()
	return ret
}

// See cairo_device_acquire().
func (device *Device) Acquire() error {
	ret := Status(C.cairo_device_acquire(device.Ptr)).toError()
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_release().
func (device *Device) Release() {
	C.cairo_device_release(device.Ptr)
	if err := device.status(); err != nil {
		panic(err)
	}
}

// See cairo_device_flush().
func (device *Device) Flush() {
	C.cairo_device_flush(device.Ptr)
	if err := device.status(); err != nil {
		panic(err)
	}
}

// See cairo_device_finish().
func (device *Device) Finish() {
	C.cairo_device_finish(device.Ptr)
	if err := device.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_create_similar().
func (other *Surface) CreateSimilar(content Content, width int, height int) *Surface {
	ret := wrapSurface(C.cairo_surface_create_similar(other.Ptr, C.cairo_content_t(content), C.int(width), C.int(height)))
	if err := other.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_create_similar_image().
func (other *Surface) CreateSimilarImage(format Format, width int, height int) *Surface {
	ret := wrapSurface(C.cairo_surface_create_similar_image(other.Ptr, C.cairo_format_t(format), C.int(width), C.int(height)))
	if err := other.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_unmap_image().
func (surface *Surface) UnmapImage(image *Surface) {
	C.cairo_surface_unmap_image(surface.Ptr, image.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_create_for_rectangle().
func (target *Surface) CreateForRectangle(x float64, y float64, width float64, height float64) *Surface {
	ret := wrapSurface(C.cairo_surface_create_for_rectangle(target.Ptr, C.double(x), C.double(y), C.double(width), C.double(height)))
	if err := target.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_observer_mode_t.
type SurfaceObserverMode int

const (
	SurfaceObserverNormal           SurfaceObserverMode = C.CAIRO_SURFACE_OBSERVER_NORMAL
	SurfaceObserverRecordOperations SurfaceObserverMode = C.CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS
)

// See cairo_surface_create_observer().
func (target *Surface) CreateObserver(mode SurfaceObserverMode) *Surface {
	ret := wrapSurface(C.cairo_surface_create_observer(target.Ptr, C.cairo_surface_observer_mode_t(mode)))
	if err := target.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_observer_elapsed().
func (surface *Surface) ObserverElapsed() float64 {
	ret := float64(C.cairo_surface_observer_elapsed(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_elapsed().
func (device *Device) ObserverElapsed() float64 {
	ret := float64(C.cairo_device_observer_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_paint_elapsed().
func (device *Device) ObserverPaintElapsed() float64 {
	ret := float64(C.cairo_device_observer_paint_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_mask_elapsed().
func (device *Device) ObserverMaskElapsed() float64 {
	ret := float64(C.cairo_device_observer_mask_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_fill_elapsed().
func (device *Device) ObserverFillElapsed() float64 {
	ret := float64(C.cairo_device_observer_fill_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_stroke_elapsed().
func (device *Device) ObserverStrokeElapsed() float64 {
	ret := float64(C.cairo_device_observer_stroke_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_device_observer_glyphs_elapsed().
func (device *Device) ObserverGlyphsElapsed() float64 {
	ret := float64(C.cairo_device_observer_glyphs_elapsed(device.Ptr))
	if err := device.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_finish().
func (surface *Surface) Finish() {
	C.cairo_surface_finish(surface.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_get_device().
func (surface *Surface) GetDevice() *Device {
	ret := wrapDevice(C.cairo_surface_get_device(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_status().
func (surface *Surface) status() error {
	ret := Status(C.cairo_surface_status(surface.Ptr)).toError()
	return ret
}

// See cairo_surface_type_t.
type SurfaceType int

const (
	SurfaceTypeImage         SurfaceType = C.CAIRO_SURFACE_TYPE_IMAGE
	SurfaceTypePdf           SurfaceType = C.CAIRO_SURFACE_TYPE_PDF
	SurfaceTypePs            SurfaceType = C.CAIRO_SURFACE_TYPE_PS
	SurfaceTypeXlib          SurfaceType = C.CAIRO_SURFACE_TYPE_XLIB
	SurfaceTypeXcb           SurfaceType = C.CAIRO_SURFACE_TYPE_XCB
	SurfaceTypeGlitz         SurfaceType = C.CAIRO_SURFACE_TYPE_GLITZ
	SurfaceTypeQuartz        SurfaceType = C.CAIRO_SURFACE_TYPE_QUARTZ
	SurfaceTypeWin32         SurfaceType = C.CAIRO_SURFACE_TYPE_WIN32
	SurfaceTypeBeos          SurfaceType = C.CAIRO_SURFACE_TYPE_BEOS
	SurfaceTypeDirectfb      SurfaceType = C.CAIRO_SURFACE_TYPE_DIRECTFB
	SurfaceTypeSvg           SurfaceType = C.CAIRO_SURFACE_TYPE_SVG
	SurfaceTypeOs2           SurfaceType = C.CAIRO_SURFACE_TYPE_OS2
	SurfaceTypeWin32Printing SurfaceType = C.CAIRO_SURFACE_TYPE_WIN32_PRINTING
	SurfaceTypeQuartzImage   SurfaceType = C.CAIRO_SURFACE_TYPE_QUARTZ_IMAGE
	SurfaceTypeScript        SurfaceType = C.CAIRO_SURFACE_TYPE_SCRIPT
	SurfaceTypeQt            SurfaceType = C.CAIRO_SURFACE_TYPE_QT
	SurfaceTypeRecording     SurfaceType = C.CAIRO_SURFACE_TYPE_RECORDING
	SurfaceTypeVg            SurfaceType = C.CAIRO_SURFACE_TYPE_VG
	SurfaceTypeGl            SurfaceType = C.CAIRO_SURFACE_TYPE_GL
	SurfaceTypeDrm           SurfaceType = C.CAIRO_SURFACE_TYPE_DRM
	SurfaceTypeTee           SurfaceType = C.CAIRO_SURFACE_TYPE_TEE
	SurfaceTypeXml           SurfaceType = C.CAIRO_SURFACE_TYPE_XML
	SurfaceTypeSkia          SurfaceType = C.CAIRO_SURFACE_TYPE_SKIA
	SurfaceTypeSubsurface    SurfaceType = C.CAIRO_SURFACE_TYPE_SUBSURFACE
	SurfaceTypeCogl          SurfaceType = C.CAIRO_SURFACE_TYPE_COGL
)

// See cairo_surface_get_type().
func (surface *Surface) GetType() SurfaceType {
	ret := SurfaceType(C.cairo_surface_get_type(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_get_content().
func (surface *Surface) GetContent() Content {
	ret := Content(C.cairo_surface_get_content(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_write_to_png().
func (surface *Surface) WriteToPng(filename string) error {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))
	ret := Status(C.cairo_surface_write_to_png(surface.Ptr, c_filename)).toError()
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_supports_mime_type().
func (surface *Surface) SupportsMimeType(mimeType string) bool {
	c_mimeType := C.CString(mimeType)
	defer C.free(unsafe.Pointer(c_mimeType))
	ret := C.cairo_surface_supports_mime_type(surface.Ptr, c_mimeType) != 0
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_surface_get_font_options().
func (surface *Surface) GetFontOptions(options *FontOptions) {
	C.cairo_surface_get_font_options(surface.Ptr, options.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_flush().
func (surface *Surface) Flush() {
	C.cairo_surface_flush(surface.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_mark_dirty().
func (surface *Surface) MarkDirty() {
	C.cairo_surface_mark_dirty(surface.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_mark_dirty_rectangle().
func (surface *Surface) MarkDirtyRectangle(x int, y int, width int, height int) {
	C.cairo_surface_mark_dirty_rectangle(surface.Ptr, C.int(x), C.int(y), C.int(width), C.int(height))
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_set_device_scale().
func (surface *Surface) SetDeviceScale(xScale float64, yScale float64) {
	C.cairo_surface_set_device_scale(surface.Ptr, C.double(xScale), C.double(yScale))
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_get_device_scale().
func (surface *Surface) GetDeviceScale() (float64, float64) {
	var xScale C.double
	var yScale C.double

	C.cairo_surface_get_device_scale(surface.Ptr, &xScale, &yScale)
	if err := surface.status(); err != nil {
		panic(err)
	}
	return float64(xScale), float64(yScale)
}

// See cairo_surface_set_device_offset().
func (surface *Surface) SetDeviceOffset(xOffset float64, yOffset float64) {
	C.cairo_surface_set_device_offset(surface.Ptr, C.double(xOffset), C.double(yOffset))
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_get_device_offset().
func (surface *Surface) GetDeviceOffset() (float64, float64) {
	var xOffset C.double
	var yOffset C.double

	C.cairo_surface_get_device_offset(surface.Ptr, &xOffset, &yOffset)
	if err := surface.status(); err != nil {
		panic(err)
	}
	return float64(xOffset), float64(yOffset)
}

// See cairo_surface_set_fallback_resolution().
func (surface *Surface) SetFallbackResolution(xPixelsPerInch float64, yPixelsPerInch float64) {
	C.cairo_surface_set_fallback_resolution(surface.Ptr, C.double(xPixelsPerInch), C.double(yPixelsPerInch))
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_get_fallback_resolution().
func (surface *Surface) GetFallbackResolution() (float64, float64) {
	var xPixelsPerInch C.double
	var yPixelsPerInch C.double

	C.cairo_surface_get_fallback_resolution(surface.Ptr, &xPixelsPerInch, &yPixelsPerInch)
	if err := surface.status(); err != nil {
		panic(err)
	}
	return float64(xPixelsPerInch), float64(yPixelsPerInch)
}

// See cairo_surface_copy_page().
func (surface *Surface) CopyPage() {
	C.cairo_surface_copy_page(surface.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_show_page().
func (surface *Surface) ShowPage() {
	C.cairo_surface_show_page(surface.Ptr)
	if err := surface.status(); err != nil {
		panic(err)
	}
}

// See cairo_surface_has_show_text_glyphs().
func (surface *Surface) HasShowTextGlyphs() bool {
	ret := C.cairo_surface_has_show_text_glyphs(surface.Ptr) != 0
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_image_surface_create().
func ImageSurfaceCreate(format Format, width int, height int) *ImageSurface {
	ret := &ImageSurface{wrapSurface(C.cairo_image_surface_create(C.cairo_format_t(format), C.int(width), C.int(height)))}
	return ret
}

// See cairo_format_stride_for_width().
func (format Format) StrideForWidth(width int) int {
	ret := int(C.cairo_format_stride_for_width(C.cairo_format_t(format), C.int(width)))
	return ret
}

// See cairo_image_surface_get_format().
func (surface *ImageSurface) GetFormat() Format {
	ret := Format(C.cairo_image_surface_get_format(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_image_surface_get_width().
func (surface *ImageSurface) GetWidth() int {
	ret := int(C.cairo_image_surface_get_width(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_image_surface_get_height().
func (surface *ImageSurface) GetHeight() int {
	ret := int(C.cairo_image_surface_get_height(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_image_surface_get_stride().
func (surface *ImageSurface) GetStride() int {
	ret := int(C.cairo_image_surface_get_stride(surface.Ptr))
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_image_surface_create_from_png().
func ImageSurfaceCreateFromPng(filename string) *ImageSurface {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))
	ret := &ImageSurface{wrapSurface(C.cairo_image_surface_create_from_png(c_filename))}
	return ret
}

// See cairo_recording_surface_create().
func RecordingSurfaceCreate(content Content, extents *Rectangle) *RecordingSurface {
	ret := &RecordingSurface{wrapSurface(C.cairo_recording_surface_create(C.cairo_content_t(content), (*C.cairo_rectangle_t)(unsafe.Pointer(extents))))}
	return ret
}

// See cairo_recording_surface_ink_extents().
func (surface *RecordingSurface) InkExtents() (float64, float64, float64, float64) {
	var x0 C.double
	var y0 C.double
	var width C.double
	var height C.double

	C.cairo_recording_surface_ink_extents(surface.Ptr, &x0, &y0, &width, &height)
	if err := surface.status(); err != nil {
		panic(err)
	}
	return float64(x0), float64(y0), float64(width), float64(height)
}

// See cairo_recording_surface_get_extents().
func (surface *RecordingSurface) GetExtents(extents *Rectangle) bool {
	ret := C.cairo_recording_surface_get_extents(surface.Ptr, (*C.cairo_rectangle_t)(unsafe.Pointer(extents))) != 0
	if err := surface.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_rgb().
func PatternCreateRgb(red float64, green float64, blue float64) *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_rgb(C.double(red), C.double(green), C.double(blue)))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_rgba().
func PatternCreateRgba(red float64, green float64, blue float64, alpha float64) *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_rgba(C.double(red), C.double(green), C.double(blue), C.double(alpha)))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_for_surface().
func PatternCreateForSurface(surface *Surface) *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_for_surface(surface.Ptr))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_linear().
func PatternCreateLinear(x0 float64, y0 float64, x1 float64, y1 float64) *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_linear(C.double(x0), C.double(y0), C.double(x1), C.double(y1)))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_radial().
func PatternCreateRadial(cx0 float64, cy0 float64, radius0 float64, cx1 float64, cy1 float64, radius1 float64) *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_radial(C.double(cx0), C.double(cy0), C.double(radius0), C.double(cx1), C.double(cy1), C.double(radius1)))
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_create_mesh().
func PatternCreateMesh() *Pattern {
	ret := wrapPattern(C.cairo_pattern_create_mesh())
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_status().
func (pattern *Pattern) status() error {
	ret := Status(C.cairo_pattern_status(pattern.Ptr)).toError()
	return ret
}

// See cairo_pattern_type_t.
type PatternType int

const (
	PatternTypeSolid        PatternType = C.CAIRO_PATTERN_TYPE_SOLID
	PatternTypeSurface      PatternType = C.CAIRO_PATTERN_TYPE_SURFACE
	PatternTypeLinear       PatternType = C.CAIRO_PATTERN_TYPE_LINEAR
	PatternTypeRadial       PatternType = C.CAIRO_PATTERN_TYPE_RADIAL
	PatternTypeMesh         PatternType = C.CAIRO_PATTERN_TYPE_MESH
	PatternTypeRasterSource PatternType = C.CAIRO_PATTERN_TYPE_RASTER_SOURCE
)

// See cairo_pattern_get_type().
func (pattern *Pattern) GetType() PatternType {
	ret := PatternType(C.cairo_pattern_get_type(pattern.Ptr))
	if err := pattern.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_pattern_add_color_stop_rgb().
func (pattern *Pattern) AddColorStopRgb(offset float64, red float64, green float64, blue float64) {
	C.cairo_pattern_add_color_stop_rgb(pattern.Ptr, C.double(offset), C.double(red), C.double(green), C.double(blue))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_pattern_add_color_stop_rgba().
func (pattern *Pattern) AddColorStopRgba(offset float64, red float64, green float64, blue float64, alpha float64) {
	C.cairo_pattern_add_color_stop_rgba(pattern.Ptr, C.double(offset), C.double(red), C.double(green), C.double(blue), C.double(alpha))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_begin_patch().
func (pattern *MeshPattern) BeginPatch() {
	C.cairo_mesh_pattern_begin_patch(pattern.Ptr)
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_end_patch().
func (pattern *MeshPattern) EndPatch() {
	C.cairo_mesh_pattern_end_patch(pattern.Ptr)
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_curve_to().
func (pattern *MeshPattern) CurveTo(x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64) {
	C.cairo_mesh_pattern_curve_to(pattern.Ptr, C.double(x1), C.double(y1), C.double(x2), C.double(y2), C.double(x3), C.double(y3))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_line_to().
func (pattern *MeshPattern) LineTo(x float64, y float64) {
	C.cairo_mesh_pattern_line_to(pattern.Ptr, C.double(x), C.double(y))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_move_to().
func (pattern *MeshPattern) MoveTo(x float64, y float64) {
	C.cairo_mesh_pattern_move_to(pattern.Ptr, C.double(x), C.double(y))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_set_control_point().
func (pattern *MeshPattern) SetControlPoint(pointNum int, x float64, y float64) {
	C.cairo_mesh_pattern_set_control_point(pattern.Ptr, C.uint(pointNum), C.double(x), C.double(y))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_set_corner_color_rgb().
func (pattern *MeshPattern) SetCornerColorRgb(cornerNum int, red float64, green float64, blue float64) {
	C.cairo_mesh_pattern_set_corner_color_rgb(pattern.Ptr, C.uint(cornerNum), C.double(red), C.double(green), C.double(blue))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_mesh_pattern_set_corner_color_rgba().
func (pattern *MeshPattern) SetCornerColorRgba(cornerNum int, red float64, green float64, blue float64, alpha float64) {
	C.cairo_mesh_pattern_set_corner_color_rgba(pattern.Ptr, C.uint(cornerNum), C.double(red), C.double(green), C.double(blue), C.double(alpha))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_pattern_set_matrix().
func (pattern *Pattern) SetMatrix(matrix *Matrix) {
	C.cairo_pattern_set_matrix(pattern.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_pattern_get_matrix().
func (pattern *Pattern) GetMatrix(matrix *Matrix) {
	C.cairo_pattern_get_matrix(pattern.Ptr, (*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_extend_t.
type Extend int

const (
	ExtendNone    Extend = C.CAIRO_EXTEND_NONE
	ExtendRepeat  Extend = C.CAIRO_EXTEND_REPEAT
	ExtendReflect Extend = C.CAIRO_EXTEND_REFLECT
	ExtendPad     Extend = C.CAIRO_EXTEND_PAD
)

// See cairo_pattern_set_extend().
func (pattern *Pattern) SetExtend(extend Extend) {
	C.cairo_pattern_set_extend(pattern.Ptr, C.cairo_extend_t(extend))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_pattern_get_extend().
func (pattern *Pattern) GetExtend() Extend {
	ret := Extend(C.cairo_pattern_get_extend(pattern.Ptr))
	if err := pattern.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_filter_t.
type Filter int

const (
	FilterFast     Filter = C.CAIRO_FILTER_FAST
	FilterGood     Filter = C.CAIRO_FILTER_GOOD
	FilterBest     Filter = C.CAIRO_FILTER_BEST
	FilterNearest  Filter = C.CAIRO_FILTER_NEAREST
	FilterBilinear Filter = C.CAIRO_FILTER_BILINEAR
	FilterGaussian Filter = C.CAIRO_FILTER_GAUSSIAN
)

// See cairo_pattern_set_filter().
func (pattern *Pattern) SetFilter(filter Filter) {
	C.cairo_pattern_set_filter(pattern.Ptr, C.cairo_filter_t(filter))
	if err := pattern.status(); err != nil {
		panic(err)
	}
}

// See cairo_pattern_get_filter().
func (pattern *Pattern) GetFilter() Filter {
	ret := Filter(C.cairo_pattern_get_filter(pattern.Ptr))
	if err := pattern.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_matrix_init_identity().
func (matrix *Matrix) InitIdentity() {
	C.cairo_matrix_init_identity((*C.cairo_matrix_t)(unsafe.Pointer(matrix)))
}

// See cairo_matrix_init_translate().
func (matrix *Matrix) InitTranslate(tx float64, ty float64) {
	C.cairo_matrix_init_translate((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(tx), C.double(ty))
}

// See cairo_matrix_init_scale().
func (matrix *Matrix) InitScale(sx float64, sy float64) {
	C.cairo_matrix_init_scale((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(sx), C.double(sy))
}

// See cairo_matrix_init_rotate().
func (matrix *Matrix) InitRotate(radians float64) {
	C.cairo_matrix_init_rotate((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(radians))
}

// See cairo_matrix_translate().
func (matrix *Matrix) Translate(tx float64, ty float64) {
	C.cairo_matrix_translate((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(tx), C.double(ty))
}

// See cairo_matrix_scale().
func (matrix *Matrix) Scale(sx float64, sy float64) {
	C.cairo_matrix_scale((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(sx), C.double(sy))
}

// See cairo_matrix_rotate().
func (matrix *Matrix) Rotate(radians float64) {
	C.cairo_matrix_rotate((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), C.double(radians))
}

// See cairo_matrix_invert().
func (matrix *Matrix) Invert() error {
	ret := Status(C.cairo_matrix_invert((*C.cairo_matrix_t)(unsafe.Pointer(matrix)))).toError()
	return ret
}

// See cairo_matrix_multiply().
func (result *Matrix) Multiply(a *Matrix, b *Matrix) {
	C.cairo_matrix_multiply((*C.cairo_matrix_t)(unsafe.Pointer(result)), (*C.cairo_matrix_t)(unsafe.Pointer(a)), (*C.cairo_matrix_t)(unsafe.Pointer(b)))
}

// See cairo_matrix_transform_distance().
func (matrix *Matrix) TransformDistance(dx *float64, dy *float64) {
	C.cairo_matrix_transform_distance((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), (*C.double)(unsafe.Pointer(dx)), (*C.double)(unsafe.Pointer(dy)))
}

// See cairo_matrix_transform_point().
func (matrix *Matrix) TransformPoint(x *float64, y *float64) {
	C.cairo_matrix_transform_point((*C.cairo_matrix_t)(unsafe.Pointer(matrix)), (*C.double)(unsafe.Pointer(x)), (*C.double)(unsafe.Pointer(y)))
}

// See cairo_region_t.
type Region struct {
	Ptr *C.cairo_region_t
}

func wrapRegion(p *C.cairo_region_t) *Region {
	// TODO: finalizer
	return &Region{p}
}

// See cairo_region_overlap_t.
type RegionOverlap int

const (
	RegionOverlapIn   RegionOverlap = C.CAIRO_REGION_OVERLAP_IN
	RegionOverlapOut  RegionOverlap = C.CAIRO_REGION_OVERLAP_OUT
	RegionOverlapPart RegionOverlap = C.CAIRO_REGION_OVERLAP_PART
)

// See cairo_region_create().
func RegionCreate() *Region {
	ret := wrapRegion(C.cairo_region_create())
	if err := ret.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_copy().
func (original *Region) Copy() *Region {
	ret := wrapRegion(C.cairo_region_copy(original.Ptr))
	if err := original.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_equal().
func (a *Region) Equal(b *Region) bool {
	ret := C.cairo_region_equal(a.Ptr, b.Ptr) != 0
	if err := a.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_status().
func (region *Region) status() error {
	ret := Status(C.cairo_region_status(region.Ptr)).toError()
	return ret
}

// See cairo_region_num_rectangles().
func (region *Region) NumRectangles() int {
	ret := int(C.cairo_region_num_rectangles(region.Ptr))
	if err := region.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_is_empty().
func (region *Region) IsEmpty() bool {
	ret := C.cairo_region_is_empty(region.Ptr) != 0
	if err := region.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_contains_point().
func (region *Region) ContainsPoint(x int, y int) bool {
	ret := C.cairo_region_contains_point(region.Ptr, C.int(x), C.int(y)) != 0
	if err := region.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_translate().
func (region *Region) Translate(dx int, dy int) {
	C.cairo_region_translate(region.Ptr, C.int(dx), C.int(dy))
	if err := region.status(); err != nil {
		panic(err)
	}
}

// See cairo_region_subtract().
func (dst *Region) Subtract(other *Region) error {
	ret := Status(C.cairo_region_subtract(dst.Ptr, other.Ptr)).toError()
	if err := dst.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_intersect().
func (dst *Region) Intersect(other *Region) error {
	ret := Status(C.cairo_region_intersect(dst.Ptr, other.Ptr)).toError()
	if err := dst.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_union().
func (dst *Region) Union(other *Region) error {
	ret := Status(C.cairo_region_union(dst.Ptr, other.Ptr)).toError()
	if err := dst.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_region_xor().
func (dst *Region) Xor(other *Region) error {
	ret := Status(C.cairo_region_xor(dst.Ptr, other.Ptr)).toError()
	if err := dst.status(); err != nil {
		panic(err)
	}
	return ret
}

// See cairo_debug_reset_static_data().
func DebugResetStaticData() {
	C.cairo_debug_reset_static_data()
}
